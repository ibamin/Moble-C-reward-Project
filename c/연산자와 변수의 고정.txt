매크로 : 단어나 문장으로 이루어진 특정한 부분이 반복적으로 쓰여질 때 반복되는 부분을 기술
사용예시
#define [기호] [대체할것]

Macro 예시코드
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define PI 3.141592

int main() {
	double radius, area;

	printf("반지름을 입력하시오:");
	scanf("%lf", &radius);
	area = PI * radius * radius;
	printf("원의 면적 : %lf\n", area);
	return 0;
}
주의할점 : double(lf) / float(f) / int(d) / char(c)

변수
const : 일반적으로 const는 함수안에서 define역활을 맡음 단 const로 지정한 변수에 지정한값은 상수가 된다.
char 1 / short 2 / int 4 / float 4 / double 8 / log double 8
signed : 부호를 지니는 값을 나타냄 흔히 생략
unsigned : 자료형 앞에 붙을 수 있는 접두사로 음수부호를 판단하지 않겠다라는 의미를 가짐 음수 부호를 판단하지 않기에
	양수쪽으로 데이터값이 2배가 됨

Data Overflow : 자료형이 담을 수 있는 데이터이상의 데이터를 입력시 가장작은 값으로 바뀜
Data Underflow : 부동 소수점 수가 너무 작아서 표현하기 힘든 상황 
Buffer Overflow : 데이터값을 넘치도록하여 다른 메모리값에 변동을 주는 공격 방식

Over flow예제 코드
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <limits.h> //각 자료형에 대한 Max/Min값을 저장하고 있는 헤더
#include <math.h>

int main() {
	short s_money = SHRT_MAX;
	unsigned short u_money = USHRT_MAX;
	printf("s_money = %d\n", s_money);
	printf("u_money = %d\n", u_money);

	s_money++;
	printf("s_money = %d\n", s_money);

	u_money++;
	printf("u_money = %d", u_money);
}

Under flow예제 코드
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#define TAX 0.2

int main() {
	float x= 1.23456e-38;
	float y= 1.23456e-40;
	float z= 1.23456e-46;

	printf("x=%e\n",x);
	printf("y=%e\n",y);
	printf("z=%e\n",z);
}


컴퓨터에서 빼기하는법
1의 보수,2의 보수,최상위 비트 1비트 표현
최상위 1비트 표현 : 3+(-3)을 연산하면 -6이 나오는 문제점이 발견됨
1의 보수 : 최후에 NOT연산을 전체적으로 진행을 해야하기 때문에 비쌈
2의 보수 : 1의 보수후에 1을 더한뒤 연산 하여 빼기 연산 진행 현재 컴퓨터는 이러한 현태의 연산을 사용중

연산자
? 삼항 연산자
형태 : x>y? [True]:[False]
. (접근 연산자) : 클래스에 선언된 함수를 사용하기 위해 사용됨
-> (.*와 같은 연산자)

쪽지시험 예상 문제
자료형 종류