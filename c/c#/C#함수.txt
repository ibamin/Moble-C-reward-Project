메서드
-일련의 코드를 하나의 이름 아래 묶은것

[한정자] [반환 형식] [메소드의 이름] ([매개변수])
{ }

클래스 메소드 : 메소드 접근제한자 뒤에 static [반환자]을 활용하여 지정 이렇게 만든 메소드는 [클래스명].[메소드명]으로 사용이 가능하다
클래스 멤버 : 멤버 접근제한자 뒤에 static [반환자]을 활용하여 지정 이렇게 만든 멤버는 [클래스명].[멤버]로 사용가능
인스턴스 메소드 : 메소드 접근제한자 뒤에 [반환자]만 활용 인스턴스(객체)를 만들어야만 접근가능
인스턴스 멤버 : 메소드 접근제한자 뒤에 [반환자]만 활용 인스턴스(객체)를 만들어야만 접근가능

//예시코드
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace App4
{
    class Test
    {
        public static int ABS(int x)
        {
            if(x< 0) { return -1*x; }
            else {  return x; }
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i < 2; i++)
            {
                Console.Write("정수 한개 입력 :");
                int x = int.Parse(Console.ReadLine());
                Console.WriteLine("Result :" + Test.ABS(x));
            }
        }
    }
}

//예시 매개변수가 배열
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace App4
{
    
    internal class Program
    {
        static void TransArr(string[] arr)
        {
            string[] strArr = { "월", "화", "수", "목", "금", "토", "일" };
            for(int i=0;i<arr.Length;i++)
            {
                arr[i] = strArr[i];
            }
        } 
        static void Main(string[] args)
        {
            string[] arr = { "Mon", "Tue", "Wed", "The", "Fri", "Sat", "Sun" };
            TransArr(arr);
            for(int i=0;i<arr.Length-1; i++)
            {
                Console.Write(arr[i]+" ,");
            }
            Console.WriteLine(arr[arr.Length-1]);
        }
    }
}

//예시 return
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static int sum(int a,int b)
        {
            int sum = 0;
            for(int i = a; i <= b; i++)
            {
                sum += i;
            }
            return sum;
        } 
        static int plus(int a,int b)
        {
            int sum = 0;
            if (b % 2 == 0)
            {
                int t = b / 2;
                sum=((a + b) * t);
            }
            else
            {
                int t = b / 2;
                sum=((a + b) * t + (t + 1));
            }
            return sum;
        }
        static void Main(string[] args)
        {
            Console.WriteLine("x~y까지의 합 구하기");
            Console.Write("x:");
            int x=int.Parse(Console.ReadLine());
            Console.Write("y:");
            int y = int.Parse(Console.ReadLine());
            Console.WriteLine(sum(x , y));
            Console.WriteLine(plus(1, y) - plus(1, x)+x);
        }
    }
}

//예시 리턴이 배열
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static int[] CreateArr(int nsize)
        {
            int[] arr = new int[nsize];
            for(int i = 0;i<nsize;i++) arr[i] = i;
            return arr;
        }

        static int[,] CreateArr2(int row,int col) {
            int[,] arr = new int[row,col];
            int index = 0;
            for(int i = 0;i<row;i++)
                for(int j = 0;j<col;j++)
                    arr[i,j] = index++;
        return arr;
        }
        static void Main(string[] args)
        {
            int[] arr1;
            int[,] arr2;
            arr1 = CreateArr(5);
            arr2 = CreateArr2(2, 3);

            for(int i=0;i<arr1.Length;i++)
                Console.Write(arr1[i]+" ");
            Console.WriteLine();
            Console.WriteLine();
            for (int i = 0; i < arr2.GetLength(0); i++)
            {
                for (int j = 0; j < arr2.GetLength(1); j++)
                    Console.Write(arr2[i, j] + " ");
                Console.WriteLine();
            }
        }
    }
}

오버로딩 : 메서드 이름은 같고 매개변수는 다른 메서드를 만드는것
//예시 코드
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        class mymath
        {
            public static int abs(int x)
            {
                if (x < 0) return -x;
                return x;
            }
            public static float abs(float x)
            {
                if(x < 0) return -x; return x;
            }
            public static double abs(double x)
            {
                if(x<0) return -x; return x;
            }
            public static decimal abs(decimal x)
            {
                if(x<0) return -x; return x;
            }
        }
        static void Main(string[] args)
        {
            for(int i = 0; i < 3; i++)
            {
                Console.WriteLine("정수를 입력하시오 :");
                int x=int.Parse(Console.ReadLine());
                Console.WriteLine("정수형 abs호출 :"+mymath.abs(x));

                Console.WriteLine("정수를 입력하시오 :");
                double y = double.Parse(Console.ReadLine());
                Console.WriteLine("정수형 abs호출 :" + mymath.abs(y));

                Console.WriteLine("정수를 입력하시오 :");
                decimal c = decimal.Parse(Console.ReadLine());
                Console.WriteLine("정수형 abs호출 :" + mymath.abs(c));
            }
        }
    }
}

가변길이 매개변수
키워드 - params
//예제 코드
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static int sum(params int[] args)
        {
            Console.Write("Summing...");
            int sum = 0;
            for (int i = 0; i < args.Length; i++) {
                if (i > 0)
                    Console.Write(", ");
                Console.Write((args[i]));
                sum+=args[i];
             }
            Console.WriteLine();
            return sum;
        }
        static void Main(string[] args)
        {
            int a = sum(3, 4, 5, 6, 7, 8, 9, 10,13,50,80,94,50,503);
            Console.WriteLine("sum:"+a);
        }
    }
}


명명된 매개변수
-메서드를 호출할 때 매개변수의 이름에 근거해서 데이터를 할당
//예제
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static void printprofile(string name,string phone)
        {
            Console.WriteLine("name :" + name + ", phone :" + phone);
        }
        static void Main(string[] args)
        {
            printprofile(name: "박찬호", phone: "010-123-1234");
            printprofile(phone: "010-987-9876", name: "박지성");
            printprofile("손흥민", "010-111-1111");
            printprofile("류현진", phone: "010-567-5678");
        }
    }
}

선택적 매개변수
-매개변수를 특정값으로 초기화
-기본값을 필요에 따라 할당하거나 안함
//예제 코드
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static void printprofile(string name,string phone="")
        {
            Console.WriteLine("name :" + name + ", phone :" + phone);
        }
        static void Main(string[] args)
        {
            printprofile(name: "박찬호");
            printprofile(phone: "010-987-9876", name: "박지성");
            printprofile("손흥민");
            printprofile("류현진", phone: "010-567-5678");
        }
    }
}


참조 복사-2번째 방식
//예제 코드
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static void swap(ref int a) //여기서의 ref는 *
        {
            a = 20;
        }
        static void Main(string[] args)
        {
            int a= 10;
            Console.WriteLine("swap 이전 :"+a);
            swap(ref a); //이곳에서의 ref는 &
            Console.WriteLine("swap 이후 :"+a);
        }
    }
}

ref는 포인터개념을 c#에서 보충해주는 참조변수이다. 
(c#은 포인터 없앤다더니 object/var/ref까지 오히려 참조 변수가 많아서 복잡한다..)
//예제 2
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    class product
    {
        int price = 100;
        public ref int GetPrice()
        {
            return ref price;
        }
        public void print()
        {
            Console.WriteLine("price :" + price);
        }
    }
    internal class Program
    {
        static void Main(string[] args)
        {
            product product = new product();
            ref int ref_price = ref product.GetPrice();
            int nomal_price = product.GetPrice();

            product.print();
            Console.WriteLine("ref_price :"+ref_price +"\nnomal_price :"+ nomal_price);
            Console.WriteLine();
            ref_price = 200;
            Console.WriteLine("ref_price 값 변경후");
            product.print();
            Console.WriteLine("ref_price :" + ref_price + "\nnomal_price :" + nomal_price);
        }
    }
}

주의해서 보아야할 점 : 원래 private형식인 int price에는 클래스 밖에서 접근이 불가능하다. 하지만 GetPrice에서
ref price를 반환했기에 원래는 알수 없었던 price의 주소값을 외부 변수에 노출하게되며 외부에있는 ref_price에서
클래스 변수의 private int price이 가리키는 데이터를 가리킬 수 있게되었고 이에 따라 ref_price를 통해 마음대로 변수를 
수정할 수 있게된다

out 키워드
ref는 에러가 발생해도 포인터이기 때문에 사용자의 의도가 있다고 생각하기에 오류를 발생시키지 않는다
하지만 문제가되는 출력을 하면 안되는 경우가 많기 때문에 out을 사용하면 출력에 문제가 발생하면 에러를 띄워준다
간단히 말하면 출력에대한 검증을 컴파일러가 인증하기 때문에 안정적이다.
//예시 코드
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        public static void divout(int a, int b, out int c, out int d) //주요
        {
            c = a / b;
            d = a % b;
        }
        static void Main(string[] args)
        {
            Console.WriteLine("두개의 정수 입력:");
            int x= int.Parse(Console.ReadLine());
            int y= int.Parse(Console.ReadLine());
            int c,d;
            divout(x, y,out c,out d); //주요
            Console.WriteLine("몫 :" + c + " 나머지 :" + d);
        }
    }
}

재귀메소드(순환메소드)
자기자신을 호출하여 loop를 도는 방식 단 이러한방식은 가독성과 재사용성을 높혀주나
함수를 지속적으로 호출하게 되어 컴퓨터의 리소스를 많이 잡아먹는 형식이기 때문에
가능하면 잘 사용하지 않는것을 권한다.
//예제
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{
    
    internal class Program
    {
        static public long get(int n)
        {
            if(n<=0) return 0;
            if(n==1) return 1;
            return get(n-1)+get(n-2);
        }
        static void Main(string[] args)
        {
            for(int i=1;i<=5;i++)
                Console.WriteLine(get(i));
        }
    }
}

메모화
재귀메소드의 구할때 구했던 값을 지속적으로 자기 자신을 호출하며 같은 값을 구하는 경우가 많기때문에
이러한 문제점을 해결할 수 있는 해결책
//예제
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        class fibo
        {
            public static DateTime start = DateTime.Now;
            private static Dictionary<int,ulong> memo = new Dictionary<int, ulong> ();
            public static ulong get(int n)
            {
                if (n <= 0) return 0;
                if (n == 1) return 1;
                
                if(memo.ContainsKey(n)) return memo[n];
                else
                {
                    ulong value = get(n - 2) + get(n - 1);
                    memo[n] = value;
                    return value;
                }
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine(fibo.get(40));
            DateTime end = DateTime.Now;
            Console.WriteLine("걸린 시간 :" + (fibo.start - end));
            Console.WriteLine(fibo.get(90));
            end = DateTime.Now;
            Console.WriteLine("걸린 시간 :" + (fibo.start - end));
        }
    }
}

분할 클래스
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        partial class myclass
        {
            public void a()
            {
                Console.WriteLine('a');
            }
            public void b()
            {
                Console.WriteLine('b');
            }
        }
        partial class myclass
        {
            public void c()
            {
                Console.WriteLine('c');
            }
            public void d()
            {
                Console.WriteLine('d');
            }
        }
        static void Main(string[] args)
        {
            myclass mc = new myclass();
            mc.a();
            mc.b();
            mc.c();
            mc.d();
        }
    }
}

확장 메서드
//예제
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;
using MyExtension; //확장 class를 가지고 있는 namespace를 사용한다고 선언

namespace MyExtension
{
    public static class IntergerExtension //이 클래스를 확장을 쓰겠다는 의미로 static추가
    {
        public static int Square(this int myint) //확장 클래스에 myint가 있다고 선언
        {
            return myint * myint;
        }
        public static int Power(this int myint,int exponent) //확장 클래스에 myint가 있다고 선언
        {
            int result = myint;
            for(int i = 1; i < exponent; i++)
            {
                result *= myint;
            }
            return result;
        }
    }
}

namespace App4
{   
    internal class Program
    {
        static void Main(string[] args)
        {
           Console.WriteLine("3^2 : "+3.Square());
           Console.WriteLine("3^4 : "+3.Power(4));
            Console.WriteLine("2^10 : "+2.Power(10));
        }
    }
}

//Test1
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        static int plus(int a, int b)
        {
            Console.WriteLine("Calling int Plus(int,int)");
            return a + b;
        }
        static int plus(int a,int b,int c)
        {
            Console.WriteLine("Calling int Plus(int,int,int)");
            return a + b + c;
        }
        static double plus(double x,double y) 
        {
            Console.WriteLine("Calling int Plus(double,double)");
            return x + y; 
        }
        static double plus(int x,double y) 
        {
            Console.WriteLine("Calling int Plus(int,double)");
            return x + y; 
        }
        static void Main(string[] args)
        {
            Console.WriteLine(plus(1,2));
            Console.WriteLine(plus(1, 2,3));
            Console.WriteLine(plus(1.0, 2.4));
            Console.WriteLine(plus(1, 2.4));
        }
    }
}
//Test2
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        class Four
        {
            public int x, y;
            public Four(int x, int y)
            {
                this.x = x;
                this.y = y;
            }
            public void check()
            {
                if (x > 0)
                {
                    if (y > 0)
                        Console.WriteLine("제 1사분면");
                    else
                        Console.WriteLine("제 4사분면");
                }
                else
                {
                    if (y > 0)
                        Console.WriteLine("제 2사분면");
                    else
                        Console.WriteLine("제 3사분면");
                }
            }
        }
        static void Main(string[] args)
        {
            Console.WriteLine("x축을 입력하세요");
            int x=int.Parse(Console.ReadLine());
            Console.WriteLine("y축을 입력하세요");
            int y=int.Parse(Console.ReadLine());
            Four a=new Four(x,y);
            a.check();
        }
    }
}
//Test 3
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        static void swap(ref int a, ref int b)
        {
            int t = a;
            a = b;
            b = t;
        }
        static void Main(string[] args)
        {
            Console.Write("정수 2개 입력 :");
            int x=int.Parse(Console.ReadLine());
            int y=int.Parse(Console.ReadLine());
            Console.WriteLine("before swap a:"+x+" b:"+y);
            swap(ref x, ref y);
            Console.WriteLine("after swap a:" + x + " b:" + y);
        }
    }
}
//Test 4
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Transactions;

namespace App4
{   
    internal class Program
    {
        static int fac(int n)
        {
            if (n == 1) return 1;
            return n * fac(n - 1);
        }
        static void Main(string[] args)
        {
            int x;
            while (true)
            {
                Console.WriteLine("팩토리얼 구할 값 입력");
                x=int.Parse(Console.ReadLine());
                if (x < 0) continue;
                if (x== 0) break;
                Console.WriteLine(x + "! 은 " + fac(x) + " 입니다.");
            }   
        }
    }
}
